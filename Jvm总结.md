### 类文件结构详解

字节码文件是JVM能够识别的文件，java文件通过编译生成字节码文件，不同的操作系统对应的字节码文件是一样的，java跨平台的原因也是因为不同操作系统上的JVM能够识别同样的字节码文件，可以通过jclasslib查看字节码文件，能够看到类的基本信息，常量池，函数，属性等。

#### 魔数

字节码文件的头四个字节称之为魔数，它的作用是确定这个文件是否是一个字节码文件，能否被JVM接收，其为固定值0xCAFEBABE。如果JVM发现读取的文件不是以这个魔数开头的，JVM会拒绝加载。



#### Class文件版本号

紧跟魔数的四个字节是Class文件的版本号，第5和第6个字节是次版本号，第7和8字节是主版本号

java -v可以查看字节码文件的主版本号信息。

高版本的Java虚拟机能够执行低版本编译器生成的Class文件，低版本的Java虚拟机不能执行高版本的编译器生成的Class文件。



#### 常量池

版本号之后的是常量池，常量池主要存放两大常量，字面量和符号引用。字面量指的是注入文本字符串，声明的final的常量值等。符号引用指的是编译原理方面的概念，例如类和接口的全限定名，字段名称和描述符，方法名称和描述符。

常量池中每一项都是一个表，标识了常量的类型，标志，描述。



#### 访问标志

接下来两个字节是访问标志，用于识别一些类或接口层次的访问信息，包括这个Class是类还是接口，是Public还是Abstract等。



#### 当前类，父类，接口索引集合

类索引用来确定当前类的全限定名。

父类索引用来确定类的父类全限定名。

接口索引描述这个类实现了哪些接口。（在集合中的顺序为implements 从左到右的顺序）



#### 字段表集合

字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。包括字段作用域，字段名称，描述符等。



#### 方法表集合

方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。



#### 属性表集合

在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。

简单来说，它是字节码文件中的一种数据结构，用来描述类、字段、方法等的附加信息。如 **调试信息**、**源代码文件名**，**异常信息**、**注解**等。



### 类加载过程

![一个类的完整生命周期](https://oss.javaguide.cn/github/javaguide/java/jvm/lifecycle-of-a-class.png)

加载：通过全类名获取对应的二进制字节流，将其所代表的静态存储结构转换为方法区的运行时数据结构，在内存中生成一个该类的Class对象，作为方法区中这些数据的访问入口。（说白了就是加载类的字节码文件并在方法区中生成一个其对应的Class类的对象）。

**注：**`Class` 对象本身在加载阶段只是一个描述类元数据的 **占位符**。它为后续的验证、准备、解析等过程提供了基础，但类的实际内容（如字段、方法、常量池等）并未完全准备好，直到后续阶段完成后，这个类才会被视为 **完全可用**，可以正常运行和调用。`Class` 对象 **确实包括类的元数据**，只是这些元数据还没经过完整的处理（比如验证、符号解析等）。在加载阶段，类的字节码被读入内存，并通过 `Class` 对象提供对类的描述和访问。

加载主要依靠的是类加载器完成。每一个类都有一个对应的类加载器。但是数组类是不通过ClassLoader创建，而是通过JVM在需要的时候创建，它的ClassLoader和其数组的元素类型的ClassLoader是一致的。

非数组类的加载过程是可控的，通过自定义一个类加载器，重写loadClass()方法即可控制其加载。加载阶段和连接阶段的动作是交叉进行的，加载尚未结束，连接就已经开始了。

链接阶段分为验证，准备，解析

验证：链接的第一步，验证阶段主要做的事情是校验工作，确保Class文件字节流符合规范，保证代码运行对JVM是安全的。

验证包括：1.文件格式验证 2.元数据验证（字节码语义检查） 3.字节码验证 4.符号引用验证

![验证阶段示意图](https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-process-verification.png)

准备阶段：为类变量分配内存并设置类变量的初始值。（不包含实例变量，实例变量存在java堆里面）类变量所使用的内存应该都在方法区分配，java8之后，这些变量都会随着Class对象放到Java堆里面。

初始值默认都是0,null，但是如果加了final关键字，则准备阶段就会赋为真实值。

解析阶段：将符号引用替换为直接引用。符号引用时一组符号来描述引用的目标，符号可以是任何的字面量。直接引用时指向目标地址的指针，例如void method()，method就可以是符号引用，但是方法所存储的地址就是直接引用。

初始化：执行初始化方法，类加载的最后一步，这一步开始才是真正执行java程序代码。初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。执行父类的静态代码块。然后对子类进行初始化，执行子类的静态代码块。还要对类中的静态变量进行初始化工作。



类卸载：即将该类Class对象GC。

卸载类满足的要求：

1.该类所有的实例对象都被GC

2.该类没有在其他地方被引用

3.该类的类加载器实例已经被GC

所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

JDK 自带的 `BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。



### 类加载器

类加载器是一个负责加载类的对象，`ClassLoader` 是一个抽象类。每个 Java 类都有一个引用指向加载它的 `ClassLoader`。不过，数组类不是通过 `ClassLoader` 创建的，而是 JVM 在需要的时候自动创建的，数组类通过`getClassLoader()`方法获取 `ClassLoader` 的时候和该数组的元素类型的 `ClassLoader` 是一致的。

**类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。（元空间）**

类加载器加载规则：只有当用到哪个类才会根据需要动态加载，这样对内存比较友好，并且在类加载的时候会首先判断这个类是否被加载过了。



#### 类加载器种类

BootstrapClassLoader：最顶层类加载器，C++实现，没有父级。加载JDK核心类库,jre/lib下的jar包（如rt.jar,resources.jar等）。

ExtClassLoader:扩展类加载器，加载jre/lib/ext目录下的jar包和类。

AppClassLoader:面向用户的类加载器，加载当前类路径下的jar包和类。

自定义类加载器：自己扩展定义的类加载器，可以完成特殊功能，比如对字节码加密，后面自己定义一个类加载器，在加载的时候对其解密。

每个 `ClassLoader` 可以通过`getParent()`获取其父 `ClassLoader`，如果获取到 `ClassLoader` 为`nul的话，那么该类是通过 `BootstrapClassLoader` 加载的。因为它是C++实现，没有对应的类，获取的结果就是null

除了BootstrapClassLoader是JVM一部分，其余都是继承ClassLoader实现的，是在JVM外部实现。



#### 自定义类加载器

继承ClassLoader抽象类，实现findClass()或者loadClass()方法。

findClass()方法，通过类名查找类，只负责加载类。**`findClass()`** 是 **具体加载类字节码的地方**。

loadClass()方法加载指定名称的类，实现双亲委派机制。有默认的实现，遵循双亲委派原则，控制加载的流程。

如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass()` 方法。



#### 双亲委派模型

![类加载器层次关系图](https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png)

每个 `ClassLoader` 实例都有一个相关的父类加载器。需要查找类或资源时，`ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。

简单总结一下双亲委派模型的执行流程：

- 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。
- 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。
- 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。
- 如果子类加载器也无法加载这个类，那么它会抛出一个 `ClassNotFoundException` 异常。

**JVM 判定两个 Java 类是否相同的具体规则**：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 `Class` 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。



打破双亲委派模型要重写loadClass方法，例如可以直接自己尝试加载这个类，而不是交给父类加载器。

好处：避免重复加载，同时保证核心类不被篡改（因为如果自己重写了一个核心类，类名一样，当类加载器加载的时候会先交给父类加载器，直到交给BootstrapClassLoader,这个时候这个类就会被BootstrapClassLoader加载，或者已经被其加载过，就不会去加载自己写的这个类，防止了核心类被篡改）。

Tomcat类加载器就重写了LoadClass方法，自定义了WebAppClassLoader来打破双亲委派机制。

在Tomcat中，会为每个部署的应用生成一个类加载器实例，叫做WebAppClassLoader，让每个应用使用自己的类加载器去加载自己的类，这样即使两个应用中可能有相同名字的类也灭有关系，不会发生冲突。实现了应用之间的类隔离。因为如果使用同一个类加载器，它不会加载两个相同类名的类加载器。当两个类名字一样，但是类加载器不一样，JVM会将其视为两个类。



### Java内存区域

java1.8之前:

![Java 运行时数据区域（JDK1.7）](https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png)

java1.8版本之后:

![Java 运行时数据区域（JDK1.8 ）](https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png)

#### 栈

线程私有。分为虚拟机栈和本地方法栈。

**程序计数器**：是当前线程执行的字节码行号指示器，通过它来指示下一条字节码指令。程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

**Java虚拟机栈**：线程私有，生命周期和线程相同。栈由一个一个栈帧组成，每个栈帧包含了局部变量表，操作数栈，动态链接和方法返回地址。也是先进先出。方法调用结束后，栈帧会被弹出。方法调用数据通过栈进行传递，每个方法的调用都会有对应的栈帧被压入栈。一个栈桢对应一个方法，非本地方法。

**栈帧**：由局部变量表，操作数栈，动态链接组成。

局部变量表存放了各种基本数据类型对应的值和对象的引用。

操作数栈用于存放方法执行过程中的中间计算结果，计算过程产生的临时变量也存在这里，作为方法调用中转站。

动态链接：作用是将符号引用转化为直接引用。发生在一个方法调用另外一个方法，当前虚拟机栈栈帧存的是方法符号引用，当具体需要调用这个方法，要把符号引用转变为方法的直接引用，这个过程叫动态链接。

（这里考可能考例如 int i = 0;i = i++;i = i++;这种操作，涉及指令iinc,istore，前者++的时候会被调用，但是这个自增是在局部变量表执行的而不是在操作数栈!!!!!!因此上述程序执行的结果还是0,i++ 先load再iinc,++i先iinc再load)

当调用出现无限循环导致栈空间太深，会抛出StackOverFlowError

Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。

StackOverFlowError:栈太深导致

OutOfMemoryError:内存空间不够导致无法申请



**本地方法栈：**

和虚拟机栈所发挥的作用非常相似(一样的），区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**



#### 堆

线程共享的区域，存放的是对象实例，**几乎**所有的对象实例以及数组都在这里分配内存。

**逃逸分析**是 JVM 在运行时对对象引用的分析，它的目标是检查对象的“逃逸”行为，即对象的生命周期是否超出了当前方法的范围。如果一个对象在创建后没有被返回或者未被外部方法引用（即它的引用没有“逃逸”出当前方法或者线程），JVM 就可以认为这个对象是局部的，且它不会在方法调用之后被使用。这样的对象可以在栈上分配内存，所以，**几乎**的意思是这个意思 。

堆也是GC回收的主要区域。

JDK7之前堆可以分为：新生代，老年代，永久代（方法区，主要存放类的元信息等），可以看到java7及之前永久代是堆内存的一部分，也是jvm内存的一部分。

JDK8之后分为:新生代，老年代，而永久代被元空间代替，元空间不再是堆内存的一部分，它使用的是本地内存。

新生代和老年代比例大概是1:2

新生代分为Eden区，S0区，S1区，比例大概是8:1:1

一般情况下，对象分配首先是在Eden区分配，垃圾回收一次后如果还存在，则会存入S0或者S1区。随着被回收次数的增加，其年龄也会逐步增加，等到到达默认的15次，会被晋升到老年代中。当然这个默认值可以自行设置。范围0-15。

为什么是0-15？因为记录年龄的区域位于对象头中，大小通常是4个二进制位。最大值是15.



#### 方法区

首先要知道这是个逻辑上的概念，是线程共享的区域。具体实现是不同的。

在jdk1.7之前，方法区是通过永久代实现的，永久代是堆的一部分，属于JVM内存。在jdk1.7之后，方法区通过元空间来实现，元空间使用的是本地内存。但是还是有区别，之前的字符串常量池存在方法区，在1.7之后存到堆里面没有在元空间，所以怎么说，元空间和永久代是实现方法区的具体方法，这两个很大部分是重叠的，但是还是不一样，例如我说的字符串常量池。

至于为什么要用元空间代替永久代：

1.永久代有固定大小上限，无法调整，元空间使用本地内存，不再占用JVM内存，内存溢出概率小了很多。

2.类元数据放到元空间中，能够加载的类会变得更多，因为其大小不再受到限制。

3.垃圾回收难度增大，因为永久代也在堆里面，这些数据的生命周期较长，不容易被回收，所以需要额外的开销来进行维护，垃圾回收难度会增大。



#### 运行时常量池

JDK7之前在永久代里面，JDK7之后在元空间中。

上面就说过类的 文件结构里面有常量池表，**运行时常量池并不是字节码文件中的常量池，而是字节码文件中的常量池在运行时的一个动态表示。**主要存放的是字面量和符号引用。常量池表就是被类加载后放入运行时常量池的。运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryError` 错误。



#### 字符串常量池

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。1.7之前，在永久代，其实也在堆里面。1.7之后就直接在堆里面，永久代没了。

字符串字面量会被存储在 **字符串常量池** 中。但是，如果创建一个新的String对象，它会复制一份字面量到堆内存。所有字面量一致的String类对象实例实际上共享一份字面量，也就是在常量池里面，这里的共享要打引号，因为我认为的共享是就只有一个这个值，但是实际上不是，看了资料。

字符串常量池从永久代移动到堆中是因为在堆中垃圾回收效率更高，之前在永久代中只有Full GC才会被回收。



#### 直接内存

直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。这些内存是通过其他代码调用在本地内存上分配的内存，不归JVM管。

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 `OutOfMemoryError` 错误出现。

JNI（Java Native Interface）就是让 Java 程序能调用其他语言（比如 C 或 C++）写的代码，或者让其他语言的程序调用 Java 代码。



#### Java对象

第一步：类加载检查

遇到new，首先检查对应类的符号引用是否在常量池中，如果在，检查这个符号引用对应的类是否被加载过，解析过，初始化过。如果没有，则先执行类的加载过程。



第二步：

类加载检查完毕后，开始为对象分配内存，相当于从堆里面划出一片内存来。 分配方式有指针碰撞和空闲列表。根据堆是否规整选择分配方式。

1.指针碰撞：将用过的内存整合到一起，没有用过的整合到一起，中间有一个分界指针，分配内存时通过这个指针移动进行。这种方式适用于堆内存比较规整，没有内存碎片的情况。

2.空闲列表：虚拟机维护一个列表，记录哪些内存块可用（起始位置，空闲空间大小），在分配的时候，找出一块足够大的内存块进行分配，然后更新列表记录，适用于堆内存不规整的情况。

内存并发问题解决方案：
1.CAS+失败重试

2.预先给线程分配一块内存。等到用完了再通过1的方式加大分配空间。



第三步：初始化零值。给对象的内存空间都初始化为0值（不包括对象头）。



第四步：设置对象头。对线头包括Mark Word和类型指针，前者有对象哈希码，GC分代年龄等，都存在对象头中。



第五步：执行初始化方法，真正的初始化。



对象内存布局：一个对象内存布局可以分为：对象头，实例数据，对齐填充

对象头包括Mark Word和类型指针。前者包括对象哈希码，GC分代年龄，锁状态等。后者是指向类元数据的指针。通过这个指针知道对象属于哪个类。

实例数据存储的是对象真正有效信息。就是i当以的各种类型字段内容。

对齐填充仅仅起到占位作用。



### 垃圾回收

java自动内存管理主要是针对对象内存的回收和对象内存的分配。最核心功能是堆内存中对象的分配和使用。

JDK7之前，堆内存分为：1.新生代内存   2.老年代内存   3.永久代

JDK8之后永久代被元空间取代，元空间使用的是直接内存。



**内存分配原则**：

1.一般都是先在Eden区分配

当Eden区没有足够空间分配的时候，会发起一次Minor GC。当对象太大，还没有达到回收要求的时候，在Minor GC的时候会把这个对象直接移动到老年代上。执行Minor GC后，后面分配的对象如果能够存在Eden区，还是会在Eden区分配内存。

2.大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。大对象直接进入老年代的行为是**由虚拟机动态决定的**，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。

3.长期存活的对象会进入老年代

由于虚拟机采用分代收集思想管理内存，会为每个对象分配一个年龄计数器。如果每次Minor GC后对象仍然能够存活在新生代中，则其计数器计数会加1，当年龄增大到默认15（CMS是6），会晋升到老年代中，这个值可以自己定义设置。最大是15。

注：这里不是绝对的，有资料说Hotspot虚拟机会统计所有对象的年龄，从小到大按照其占有的内存空间进行累计，当累积到某个年纪其大小超过survivor区的百分之五十，则取这个年纪和默认回收年纪中更小的一个作为晋升年龄的阈值。（动态的）

4.进行GC的区域（1）新生代收集：只针对新生代进行垃圾回收  (2)老年代收集：只针对老年代进行垃圾回收 （3）混合收集：对整个新生代和部分老年代进行垃圾回收 （4）整堆收集：收集整个java堆和方法区。

5.空间担保机制：主要是要确在Minor GCh前老年代本身还能够荣男新生代所有对象的空间。判断规则是只要老年代连续空间大于新生代对象总大小或者大于历次晋升的平均大小，就会进行Minor GC否则进行Full GC。



#### 判断对象是否能被回收的方法

**引用计数器法**

当有对象引用他计数器就加1，当引用失败，计数器就减1，计数器值为0的对象就是不会再被使用的。

特点：方法比较简单，效率高，但是难以解决对象之间循环引用的问题。

**可达性分析法**

通过一系列GC Roots的对象作为起点，从这些节点向下搜索，这些走过的路径成为引用链，如果一个对象没有存在于任何以一个引用链上，则这个对象不可用，需要被回收。

GC Roots:包括虚拟机栈中引用的对象，本地方法栈中引用的对象，方法区中类静态属性引用的对象，常量引用的对象等。



#### 引用类型总结

强引用，软引用，弱引用，虚引用。

强引用：大部分的引用都是强引用，也是最普遍的引用，例如new....，如果一个对象具有强引用，则垃圾回收器一定不会回收它。

软引用：若一个对象只有软引用，内存空间足够，垃圾回收器不会回收它，内存空间不足，则会回收这些对象的内存。可以用来实现内存敏感的告诉缓存。

弱引用：不管当前内存空间是否足够，都会回收只有软引用的对象的内存。这个对象拥有更短暂的生命周期。

虚引用：主要来跟踪对象被垃圾回收的活动，形同虚设，他不决定对象生命周期，什么时候回收也不是他说了算。它主要是跟踪，跟踪，跟踪。一般和一个引用队列一起使用，当这个虚引用指向的对象**将要被垃圾回收**，则会把这个虚引用加入到与之关联的引用队列中，这样程序就可以得知这个对象是否被回收，可以采取一些必要的动作。

事实上，刚刚说的配合引用队列使用，软引用和弱引用也有这个功能。但是它们更高效，因为垃圾回收的速度更快。



#### 方法区垃圾回收

当类不再被使用且没有任何活跃的引用时，JVM 会回收该类对应的 **Class 对象**，释放相关的元数据。

一个类能被回收：

1.所有这个类对应的实例对象全都被回收了

2.这个类对应的类加载器被回收

3.这个类对应的Class对象没有在任何地方被引用



### 垃圾回收算法

#### 标记-清除算法

先标记**不需要回收的对象（有争议，但是根据可达性分析法，倾向于标记的是不可回收对象，因为都能通过链快速找到）**，然后统一回收掉所有没有被标记的对象。

问题：1.标记，清除效率不高。2.会产生大量不连续内存碎片。

#### 复制算法

为了解决标记-清除算法的内存碎片问题，复制算法出现，将内存分为大小相同的两块，每次使用其中一块，当这一块用完后，将存活的对象复制到另一块区，然后再把空间一次性清理掉，则完成了回收。

问题：1.可用内存变小，变成原来一半。2.对象如果太大，复制性能会很低。不适用老年代。

#### 标记-整理算法

和标记清除差不多，但是后续不直接回收，而是让所有存活对象移动到一端，然后清理掉边界之外的。主要适用于老年代，但是效率不高。

#### 分代收集算法

按照内存划分，针对不同的内存区域使用不同的垃圾收集算法。主要还是为了提高效率，因为上面三种算法针对不同类型场景的对象进行回收，例如复制算法可能更适合年轻代，而标记清除和标记整理更适合老年代。（这丫是为什么要分新生代和老年代的目的，就是为了提高垃圾回收的效率)



### 垃圾回收器

**收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**

JDK有默认垃圾收集器，通过命令可以查看，JDK9-JDK22默认都是G1

#### Serial

特点：单线程，串行，垃圾回收的时候暂停所有其他工作线（STW），简单，没有线程交互开销。

新生代采用复制算法，老年代使用标记整理算法。

![Serial 收集器](https://oss.javaguide.cn/github/javaguide/java/jvm/serial-garbage-collector.png)

#### Serial Old

Serial的老年代版本，也是单线程收集。

#### ParNew

Serial的多线程版本，使用多线程进行垃圾回收，其余和Serial一样。

![ParNew 收集器 ](https://oss.javaguide.cn/github/javaguide/java/jvm/parnew-garbage-collector.png)

并行回收：多个垃圾回收线程并行工作

并发回收：垃圾回收线程和工作线程并行工作



#### Parallel Scanvenge

年轻代垃圾回收器，和ParNew差不多，但是新增了很多功能，它关注点是吞吐量，即高效使用CPU，吞吐量指的是运行用户代码总时间和CPU消耗总时间的比值。Parallel Scavenge允许手动设置最大暂停时间和吞吐量。如果手动优化困难，可以使用自适应调节策略。

JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old

![Parallel Old收集器运行示意图](https://oss.javaguide.cn/github/javaguide/java/jvm/parallel-scavenge-garbage-collector.png)



#### Parallel Old

**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。



#### CMS

真正意义上第一款并发垃圾回收器，实现了垃圾回收线程和用户线程的同时工作。采用**标记清除**算法，针对的是老年代垃圾回收。

主要过程包括：

![CMS 收集器](https://oss.javaguide.cn/github/javaguide/java/jvm/cms-garbage-collector.png)

初始标记：会短暂STW，标记GC Roots关联的根对象。

并发标记：开启GC线程和用户线程的并行运行，记录可达对象，但是这里GC线程无法覆盖所有可达对象，因为在这个过程中工作线程也在工作，可能会产生新的可达对象。

重新标记：修正并发标记过程中因为用户线程而导致发生变化的那一部分对象，也会STW，但是时间比初始标记要长很多，比并发标记要短很多。

并发清除：用户线程和垃圾回收线程一起工作，对没有标记的对象进行清除。

**优点**：并发收集，低停顿。

**缺点**：使用标记清除会产生很多内存碎片，对CPU敏感（如果 CPU 紧张，回收效率低，可能导致更长的停顿，因为并发执行），无法处理浮动垃圾（我的理解是并发清除阶段产生的可回收对象）。java9已经默认不使用，java14直接被移除。



#### G1

paralle scanvenge关注吞吐量，而CMS关注暂停时间，G1将其优点进行融合。

同时回收新生代和老年代，G1独特的内存布局不再遵循新生代，老年代的划分，而是将内存划分为一个又一个Region。大小1-32M,都是2的n次幂。region逻辑上划分Eden,Survivor和老年代。每个分区都有可能是Eden,Survivor或者老年代。但是一个时刻只能是一种分区。每个分区的region数量也不固定，内存也不固定，逻辑上这些region连续，但是物理上并不连续。

并且还多了一种特殊分区叫做Humongous区，大对象区，用来存放大对象，如果一个对象容量超过了Region大小的一般，则会将其放入大对象区。原因是，G1对新生代的垃圾回收采用复制算法，如果对象太大，复制的代价太高。但是如果直接把对象放入老年代，如果这个对象本身是短期使用，则更不利于回收。所以如果一个对象大小超过了一个Region大小的一半，需要找到大对象区存放，如果找不到连续的大对象区则开启Full GC.

每个Region内部被划分成多个内存块，成为card,card的集合叫做卡表。是Region的内部结构划分。

每个Region还有RSet,是一个哈希表key是引用本region的其他region的起始地址，value是本region中被key所代表的region引用的card索引位置。

G1垃圾回收方式有两种

1.年轻代回收

主要是回收Eden区和Survivor区中不用的对象，会导致STW,时间可以通过参数设置。设置后G1垃圾回收器会尽可能保证暂停时间。

G1执行的整个流程：

（1）新创建的对象都会放在Eden区。当G1判断年轻代不足，无法分配对象会执行Young GC。

（2）标记出Eden区和Survivor区中存活的对象。

（3）根据配置的最大暂停时间选择某些区域将存活对象复制到新的Survivor区，对象年龄加1，清空这些区域。

这个过程中G1会根据垃圾回收的平均耗时，作为下次垃圾回收的参考依据，根据配置的最大暂停时间就能知道最多能回收多少个Region区域。

（4）某个对象存活年龄达到阈值默认15，将被放入老年代。

值得注意的是，之前提过，如果对象大小本身就超过一个Region的一半，则会被直接放入大对象区。



2.混合回收

当老年代区在总堆占有率达到阈值，默认百分之四十五，会触发混合回收，回收所有年轻代和部分老年代对象以及大对象区。采用复制算法完成。

混合回收过程分为：初始标记，并发标记，最终标记，并发清理。

![1736516725373](C:\Users\17898\Documents\WeChat Files\wxid_ilsb8mab1nud22\FileStorage\Temp\1736516725373.png)

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。

**混合回收**：在 G1 中，混合回收会根据堆的使用情况和回收目标，选择性地回收新生代和老年代的部分区域。其目的是在不导致长时间停顿的情况下，清理内存中的垃圾。

**Full GC**：是最全面的垃圾回收，通常需要暂停所有应用线程，并且会进行全堆区的回收。它通常是在 **内存不足** 或 **垃圾回收器无法继续有效回收** 时触发。



**三色标记**

白色标记：还没被检查的对象。

灰色标记：已经被检查的对象，但是引用它的对象还没被检查。

黑色标记：已经被检查且引用它的对象也被检查了。



3.Full GC

使用标记-整理算法，如果清理过程中发现没有足够的空Region存放转移对象，会触发Full GC，此时会STW，单线程采用标记-整理算法回收全堆区。时间很长，因此尽量要保证堆内存要有多余空间，避免Full GC。



#### ZGC

东西也太他妈多了吧 我真服了 

