### 数据库

主键和外键的区别？

主键用来唯一标识一个元组，不能重复，不允许为空，一个表只能有一个主键。

外键用来和其他表建立联系，外键是另外一个表的主键，外键可以有多个，可以重复，也可以为空。



### **什么是存储过程？**

就是一些SQL语句的集合，中间加了一些逻辑控制语句。



### MySQL基础常见的问题

unsigned:无符号，可以将正整数的上限提高一倍，因为不再需要存储负值。

char和varchar的区别:char是定长字符串,varchar是变长字符串。char存储的时候会在右边填充空格以便达到指定长度，检索的时候会去掉空格。varchar存储的时候需要1--2个字节来记录字符串的长度，检索的时候无需处理。

char适合存储较短或者长度和设置长度差不多的字符串，而varchar适合存储长度不确定或者差异较大的字符串。

CHAR(M) 和 VARCHAR(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。

varchar(100)和varchar(10)如果存储的是相同长度的字符串，则所占的磁盘存储空间是一样的。但是前者会消耗更多的内存，因为操作varchar类ing需要分配固定大小的内存块保存值。

DECIMAL 和 FLOAT 的区别是：**DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT/DOUBLE 只能存储近似的小数值。**

DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。

**`DECIMAL` 通过存储整数来表示小数。比如 1.23 可以存储为 123，结合一个标记的小数位（2 位），确保数字精确到特定的小数位置。**

TEXT类型和Blob类型不推荐使用，因为检索效率低下，无法直接创建索引，需要指定前缀等。

DATETIME没有时区信息，TIMESTAMP和时区相关。前者需要8字节存储空间，后者只需要4字节。所以后者的时间范围更小。



NULL值代表确定，即使两个NULL值也不一定相等。''不占据空间，但是NULL会占据存储空间。聚合函数使用会忽略NULL值，Count函数如果是Count(*)会统计NULL值，如果是COUNT(列名)则不会统计NULL值。查询NULL值必须使用IS NULL或者IS NOT NULL来判断。



MYSQL一条语句执行整个流程

![img](https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png)

首先，用户通过连接器连接到MySQL,这个过程需要进行身份认证和相关权限确认。执行SQL语句的时候，首先通过分析器，经过词法分析，语法分析，查询缓存，执行查询语句，命中则执行，否则不执行。然后通过优化器对查询语句进行优化，得到最优方案。然后通过执行器执行，从存储引擎中返回数据，执行语句会先判断是否有权限，没有权限会报错。



### MySQL索引

索引是一种用来快速检索数据的数据结构，本质上是一种排好序的数据结构。

常见的索引结构有：B+树，B树，红黑树，HASH

优点：能够提高数据检索速度，减少I/O次数，创建唯一性索引也可以保证每行数据的唯一性。

缺点：维护索引需要耗费时间。对数据增删改查需要动态修改索引，也会降低SQL执行小笼包，索引需要物理空间存储，会耗费一定空间。数据量不大的时候，使用索引也不一定能带来很大效率的提升。



#### 索引的结构

##### Hash表

InnoDB引擎是不支持常规的Hash索引的。但是InnoDB中存在特殊的**"自适应哈希索引"**,结合了B+树和哈希索引的特点，每个哈希桶实际上是一个B+树结构，存储多个键值对，可以通过自适应哈希索引快速检索到常用的数据。这些自适应哈希索引的建立与删除都是由InnoDB引擎自己决定的。

MySQL之所以不把hash作为索引结构是因为它不支持范围查询和顺序查询。



##### 插播题外话红黑树

红黑树的特点：根叶黑，不红红，左根右，黑路同。

根节点和叶子节点默认是黑色的，叶子节点是黑色的（这里说的叶子节点是虚拟的叶子节点），如果父节点是红色，子节点一定是黑色，不能都是红色。而且红黑树本身首先得是一个二叉排序树，从每个节点出发到其叶子节点，不同分支上黑色节点的数量是相同的。

为什么红黑树更好？AVL树是严格的平衡，虽然能够保证查询效率达到log(n + 1)，但是由于高度的平衡性要求导致了频繁的插入删除带来的树结构调整，会产生很多开销。红黑树平衡条件并不苛刻，但是它很大程度上能够减少调整操作的次数，而且其查询效率也是2log(n+1),因此更被青睐。



##### B树和B+树

B+树的非叶子节点只存储key，叶子节点存储key和value。

B树的非叶子节点和叶子节点都会存储key和value。

B树的叶子节点之间是独立的，B+树的叶子节点直接会有指针进行连接。

如果检索一个范围的数据，B树的检索类似于对每个数据进行一次二分查找，可能还没到根节点就已经检索完了。但是B+树的检索，必须到达根节点，然后可以进行顺序查找，其检索更加稳定。所以B树的范围查找可以使用中序遍历。但是B+树可以直接使用链表的遍历。B+树对比B树其查找效率更加稳定。

按照存储方式分类，索引分为：

非聚簇索引：MyISAM引擎采用这种方式，索引文件和数据文件分离，索引文件也采用B+树形式组织，但是其data域保存的是指向对应数据的指针。这种方式叫做非聚簇索引。

优点：更新代价很小，由于存储的是索引值，叶子节点不存放数据，只存放地址，所以索引值对应的值发生变化也没有关系。

缺点：叶子节点存的是索引值，所以还需要一次查表查找到对应的值，可能需要二次查表。而且也依赖于有序的数据。



聚簇索引：索引文件和数据文件是同一个，data域保存的是完整的数据记录，表数据文件本身也是索引文件。InnoDB中,.ibd文件就包含了该表的索引和数据。

优点：查询速度很快，定位到索引的节点也就定位到了数据，不需要像非聚簇索引那样再进行一次IO操作。

缺点：依赖于有序的数据，数据如果无序，需要在插入的时候排序，如果是UUID类的数据很难排序，插入或者查找速度慢。更新代价大，如果索引列的数据被修改，索引也会被修改，叶子节点由于存放数据，导致修改代价很大，整个树可能结构会大变。



#### 索引的类型

主键索引：针对主键建立的索引，不能有NULL值，表中只有一个。

普通索引：仅仅作为加锁查询使用。

唯一索引：加速索引，列值唯一，可以有NULL值。

覆盖索引：一个索引包含了要查询的所有字段的值。（不需要回表了）。

联合索引：多个列值组成一个索引。

全文索引：对文本内容进行分词，进行搜索，CHAR,VARCHAR,TEXT可以建立全文索引。

前缀索引：通过文本的前几个字符创建的索引，比普通索引建立的数据更小，因为只取了前几个字符。

函数索引：8.x之后支持，在索引中使用函数或者表达式的值。

降序索引：8.x之后开始支持真正的降序索引。



主键索引也是一级索引

值唯一，不能为NULL，不能重复。如果没有指定主键，会检查是否有唯一索引且不允许存在NULL的字段，有的话就是使用这个字段作为默认的主键，否则会创建一个自增主键DB_ROW_ID列，6字节。



二级索引包括了唯一索引，普通索引，前缀索引等。

二级索引的B+树叶子节点不是对应的值，而是主键，通过找到这个主键再去查找一级索引才能最终检索得到数据。

按照存储方式分类，索引分为：

非聚簇索引：MyISAM引擎采用这种方式，索引文件和数据文件分离，索引文件也采用B+树形式组织，但是其data域保存的是指向对应数据的指针。这种方式叫做非聚簇索引。

优点：更新代价很小，由于存储的是索引值，叶子节点不存放数据，只存放地址，所以索引值对应的值发生变化也没有关系。

缺点：叶子节点存的是索引值，所以还需要一次查表查找到对应的值，可能需要二次查表。而且也依赖于有序的数据。



聚簇索引：索引文件和数据文件是同一个，data域保存的是完整的数据记录，表数据文件本身也是索引文件。InnoDB中,.ibd文件就包含了该表的索引和数据。

优点：查询速度很快，定位到索引的节点也就定位到了数据，不需要像非聚簇索引那样再进行一次IO操作。

缺点：依赖于有序的数据，数据如果无序，需要在插入的时候排序，如果是UUID类的数据很难排序，插入或者查找速度慢。更新代价大，如果索引列的数据被修改，索引也会被修改，叶子节点由于存放数据，导致修改代价很大，整个树可能结构会大变。



覆盖索引：要查找的字段都能在索引中直接找到，叫做覆盖索引。最大的好处就是不需要回表查询了。

联合索引：对多个字段建立索引。也就是联合索引。

最左前缀匹配原则：使用联合索引的时候，会根据索引的字段顺序，从左到右匹配查询条件中的字段。如果查询条件与索引中最左侧字段匹配，则MySQL就会使用索引过滤数据。可以提高查找效率。

最左匹配会一直向右查询知道遇到范围匹配（如>,<）为止。对于>=,<=，between以及前缀匹配Like的范围查询（`LIKE` 只有前缀匹配时才能利用索引），不会停止匹配。

联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。**也就是范围查询的字段可以用到联合索引，但是范围查询字段的后面的字段无法用到联合索引**。

8.0.13之后引入了索引跳跃扫描，在某些索引查询场景下提高效率。之前如果不满足最左前缀匹配法则的联合索引会执行全表扫描，而索引跳跃扫描会允许在不满足最左前缀匹配的情况下避免全表扫描。



**索引下推**

是一种索引优化功能，允许存储引擎在索引遍历过程中，执行部分where字句的判断条件，直接过滤掉不满足的记录，减少回表查询次数，提高效率。

SELECT * FROM user WHERE zipcode = '431200' AND MONTH(birthdate) = 3;

索引下推的**下推**其实就是指将部分上层（Server 层）负责的事情，交给了下层（存储引擎层）去处理。

没有索引下推之前：

- 存储引擎层先根据 `zipcode` 索引字段找到所有 `zipcode = '431200'` 的用户的主键 ID，然后二次回表查询，获取完整的用户数据；
- 存储引擎层把所有 `zipcode = '431200'` 的用户数据全部交给 Server 层，Server 层根据`MONTH(birthdate) = 3`这一条件再进一步做筛选。

有了索引下推之后：

- **存储引擎层**先根据 `zipcode` 索引字段找到所有 `zipcode = '431200'` 的用户，然后直接判断 `MONTH(birthdate) = 3`，筛选出符合条件的主键 ID；
- 二次回表查询，根据符合条件的主键 ID 去获取完整的用户数据；
- **存储引擎层**把符合条件的用户数据全部交给 Server 层。

**除了可以减少回表次数之外，索引下推还可以减少存储引擎层和 Server 层的数据传输量。**



1. 子查询不能使用索引下推，因为子查询通常会创建临时表来处理结果，而这些临时表是没有索引的。
2. 存储过程不能使用索引下推，因为存储引擎无法调用存储函数。
3. 适用于 InnoDB 引擎和 MyISAM 引擎的查询。



#### 索引使用的注意事项

1.选择合适字段（尽量不为NULL，被频繁查询的字段，作为条件被查询的字段等）。

2.频繁更新的字段应该慎用索引。

3.索引数量要控制到5个以内。因为索引也会占据存储空间，并且修改也耗时。

4.避免冗余索引

5.避免索引失效

（1）创建联合索引但没有遵循最左匹配原则

（2）在索引列上计算，函数操作等

（3）Like查询 "%abc"这种

（4）在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。这个的优化方式就是 在 Or 的时候两边都加上索引

（5） IN 肯定会走索引，但是当 IN 的取值范围较大时会导致索引失效，走全表扫描



### MySQL日志

MySQL 中常见的日志有哪些？

慢查询日志有什么用？

binlog 主要记录了什么？

redo log 如何保证事务的持久性？

页修改之后为什么不直接刷盘呢？

binlog 和 redolog 有什么区别？

undo log 如何保证事务的原子性？



MySQL的三大日志:undo log,redo log,bin log

bin log日志：二进制日志，是服务层的日志，用来保证数据一致性，在主从复制的时候起作用。作用：主从复制，在灾难时进行数据恢复

有三种格式Statement,Row,Mixed

第一种类型中存储的是SQL语句，第二种存储的是修改后的行数据，第三种是前面两种的混合。

为什么需要第二种？因为如果记录的语句中存在now()这种函数，获取系统时间会直接导致执行结果和之前原数据库的结果不同。因此例如这种数据不能通过第一种方式存储。

**binlog写入**：事务执行过程中，首先把日志写到binlog cache，然后再把binlog cache中的内容写入到binlog文件中。一个事务的binlog不能被拆开，一定要一次性写入，因此binlog cache每个线程都有。然后通过fsync持久化到磁盘。写入的间隔时间可以自行设置，但是要注意如果设置的太长可能会导致数据的丢失。



redolog

重做日志，InnoDB存储引擎独有的，能够让MySQL有崩溃恢复的能力。如果MySQL实例挂了,重启后会使用这个日志进行数据恢复，保持数据的**持久性**和完整性。

在InnoDB存储引擎中，数据的组织形式逻辑结构是：表空间-段-区-页-行  一个页大小16KB 一个区有64个页

内存结构方面，其分为Buffer Pool(包括了Change Buffer,Log Buffer等)，自适应哈希索引

当读取数据的时候，首先会查看Buffer Pool中是否有数据，没有命中再去硬盘中加载，减少必要的IO操作。更新的时候首先在Buffer Pool中更新，如果有数据则直接更新，否则去磁盘读取，然后再更新。所有的操作会被记录在redo log buffer中，然后再刷盘到redo log里。刷盘时机根据策略调整。

刷盘时机：

1.事务提交：事务一提交，redo log buffer数据即被刷盘（`innodb_flush_log_at_trx_commit`参数控制）

2.log buffer空间不足:如果缓存的日志已经占据了log buffer总容量一半以上，则需要将这些日志刷盘。

3.正常关闭服务器的时候，redo log会被刷到磁盘

4.InnoDB定期执行检查点擦偶哦，将内存脏数据刷到磁盘，同时将相应的重做日志页刷新到磁盘

5.InnoDB 存储引擎有一个后台线程，每隔`1` 秒，就会把 `redo log buffer` 中的内容写到文件系统缓存（`page cache`），然后调用 `fsync` 刷盘。



`innodb_flush_log_at_trx_commit`参数有三个值:  默认是1

0:  每次事务提交都不刷盘  安全性低 但效率高

1：每次事务提交都刷盘     安全性高  但效率低

2：每次事务提交都将redo log buffer内容写入page cache,这里有缓存redo log文件  安全性中等

![image-20250117142810238](C:\Users\17898\AppData\Roaming\Typora\typora-user-images\image-20250117142810238.png)



undo log:回滚日志 和redo log一样都是InnoDB存储引擎层生成的日志，实现事务的**原子性**，主要用于事务回滚和MVCC。发生回滚的时候，需要读取undo log的数据，然后执行相反的操作。它是一种逻辑日志，记录的是sql语句。同时undolog的信息也会被记录到redo log中，因为他也需要持久性保护，会在事务提交后被清理。undo log会被记录在undo log日志段里面，而undo log日志段包含在rollback段里面，每个undo log都对应一个undo log日志段，一个rollback日志段有1024个undo log日志段。



redolog和undolog的区别和作用:redolog记录的是事务提交后的数据状态，用来进行数据持久化，由于本身数据的存储结构，并不会在事务一提交就将其持久化到内存中，而是等待特定的时期，如果这个时候发生了MySQL的宕机，则恢复后就可以通过redo log日志恢复数据。undo log记录的是事务还没有提交前的修改，如果事务并没有提交，这个时候发生了MySQL宕机，则在恢复服务后，可以通过读取undo log日志的信息进行事务回滚。二者针对的应用场景也有所不同。

binlog日志能否取代redo log日志：不可以。两者针对的场景也不同，binlog日志主要是用于主从同步和数据恢复，而redolog日志主要是保证事物的ACID属性。只有事务完全提交后，才会写入binlog，而任何对数据库的修改操作都会被写入redo log。因此如果数据仅仅是写入Buffer Pool 此时如果宕机（已经写入redo log了），再次恢复，只有通过redo log才能去识别出这些脏数据，而binlog根本无法识别这些数据是否是脏数据。（准确来说 有了redo log才有可能恢复脏数据 保证事务的ACID属性）



#### 两阶段提交

事务提交成功后，redo log和binlog要持久化到磁盘，这是两个独立逻辑，可能出现半成功的状况。会导致不一致性。

因此将redo log的写入拆成两个部分，通过两阶段提交来解决这个问题。这需要内部XA事务协作。

分别是prepare阶段和commit阶段

prepare阶段:将XID（XA事务的ID）写入到redo log,同时将redo log对应的事务状态修改为prepare,将redo log持久化到磁盘。

commit阶段:将XID写入binlog，将binlog持久化到磁盘，然后将redo log的状态设置成coomit,此时该状态还不需要持久化到磁盘，只需要write到pagecache即可，因为只要binlog写磁盘成功，redo log状态时prepare也没有关系，也会被认为提交成功。

两阶段提交是以binlog的写入成功为成功标识，只要binlog写成功，则就能在binlog中找到和redo log相同的XID。

![image-20240725231850469](https://cdn.xiaolincoding.com//picgo/image-20240725231850469.png)

#### MySQL的事务

事务指的是逻辑上的一组操作，要么都执行，要么都不执行。

事务的ACID特性：原子性，一致性，隔离性，持久性

**多事务并发导致的问题**：

1.脏读：一个事务读取数据并对其做了修改，这个修改对于其他事务是可见的，即使事务还没有提交。就是说一个事务读取到了其他事务还没有提交而数据，如果前一个事务突然回滚，就会导致第二个事务读出来的数据是脏数据。

2.丢失修改：一个事务读取一个数据时，另一个事务也访问这个数据，如果前一个事务修改了这个数据，第二个事务也修改了这个数据。这样会导致第一个事务内的修改被丢失。

3.不可重复读：读同一个数据，第一个事务连读两次中间如果第二个事务对数据进行了修改，可能会导致读出来的数据不一致。

4.幻读：和3类似，发生在一个事务连读了几行数据过程中，被另外一个事务插入了一些数据，随后查询中，第一个事务发现了很多原本不存在的记录，好像发生了幻觉。



并发事务的控制方式：锁和MVCC，前者思想是乐观锁，后者的思想是悲观锁。



#### 事务的隔离级别

读未提交：最低隔离级别，允许读取尚未提交的数据，可能导致脏读幻读不可重复读。

读已提交：允许读取并发事务中已经提交的数据，可以阻止脏读，但是仍有可能发现幻读和不可重复读。

可重复读：对一个字段的读取结果是一致的，除非事务是被本身事务修改，可以阻止脏读和不可重复读，但是幻读任有可能发生。

串行化：最高隔离级别，完全服从ACID特性，能防脏读，幻读，不可重复读。

MySQL的隔离级别是基于锁和MVCC机制共同实现的，串行化隔离级别通过锁来实现，读已提交和可重复读是通过MVCC实现。可重复读在当前读的情况下需要使用加锁来保证不会出现幻读。

默认隔离级别是可重复读。



表级锁：针对非索引字段家的所，对当前整张表加锁，实现简单，资源消耗比较少加锁快，不会出现死锁。但是出发锁冲突的概率比较高。高并发下效率比较低，表级锁和存储引擎无关，MyISAM和InnoDB引擎都支持表级锁。

行级锁：针对索引字段加的锁，只针对当前操作的行记录进行加锁。能够大大减少数据库操作的冲突，加锁粒度最小，并发度最高，但是开销也很大，加锁慢。注意：它是针对索引字段加的锁，如果字段没有索引或者索引失效，则会升级成表级锁。



锁机制

全局锁  表级锁  行级锁

全局锁：用在数据库备份的时候，全局锁锁的是整个数据库，锁了以后任何对数据库的操作都将不再被允许。全局锁一般只有全局读锁

表级锁：表锁，元数据锁，意向锁

表锁：分为表级读锁和表级写锁

加了表级读锁之后可以读表数据，但是不能再写表数据。

元数据锁（MDL）：用来保证表的元数据即表结构不能发生变化，系统自动控制，当访问表数据的时候自动加上去，防止对于数据的修改。

意向锁：如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁快速判断是否可以对某个表使用表锁。

意向锁和意向锁之间是兼容的，但是意向锁和其他表级锁可能不兼容，意向共享锁和表级别共享锁兼容。其他的都不兼容。



当前读和快照读：

当前读：读取到的是记录的最新版本，读取还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。

快照读：不加锁的select就是快照读，快照读读取的是记录的历史版本，不加锁，非阻塞读。





**行级锁**

分为记录锁，间隙锁，临键锁

记录锁：单个行记录上面的锁

间隙锁：锁定一个范围，不包括记录本身

临键锁：锁定一个范围，包含记录本身，主要是为了解决欢度问题。

默认使用的是临键锁，但如果操作的索引是唯一索引或者主键，则会对其进行优化，降为记录锁。

****

### 存储引擎

存储引擎负责管理数据的存储，检索和更新方式，实现不同的事务，索引和锁机制以优化数据库性能和可靠性。

InnoDB,MyISAM,Memory

InnoDB引擎支持事务，支持外键，行级锁，B+树索引（还有自适应哈希索引），支持MVCC（MVCC可以看作是行级锁的升级）

MyISAM引擎不支持事务，不支持外键，使用表级锁和B+树索引。所以查询效率慢，而且由于不支持事务，崩溃后难恢复，5.5之前风光一时。而且虽然InnoDB和MyISAM都是采用B+树索引，但是MyISAM是采用所以文件和数据文件分离的做法，而InnoDB中，数据文件本身就是索引文件，叶子节点在data域保存了完整的数据。

Memory存储引擎无法持久化数据，支持表级锁。

MySQL存储引擎的架构是**插件式架构**，支持多种存储引擎，存储引擎是基于表而不是数据库。

![MySQL architecture diagram showing connectors, interfaces, pluggable storage engines, the file system with files and logs.](https://oss.javaguide.cn/github/javaguide/mysql/mysql-architecture.png)



### MVCC多版本并发控制

锁机制已经能够实现事务的隔离级别了，能够保证多事务并发访问数据库。但是加锁机制很耗费时间，可能会导致事务的阻塞，所以引入了多版本并发控制机制，即MVCC来实现不同事务对于数据库的正确读取。这是一种避免加锁的并发控制机制，保证每个事务能够看到自己最开始的数据版本，能够非阻塞读取数据，避免加锁带来的性能损耗。



快照读：读取的记录时之前的历史版本。在RC即读已提交的隔离级别下每次读取都会生成一个快照，在可重复读RR隔离级别下，只会在第一次读的时候生成快照。

当前读：读取的是记录的最新版本。读取还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。

MVCC的实现依靠三个东西

数据库表隐藏的三个字段：DB_TRX_ID:最后一次修改这行数据的事务ID，DB_ROLL_PTR:指向undo log,存储数据版本信息，可以找到之前的数据版本，实现多版本控制，DB_ROW_ID:自增行标识符，没有主键的会把这个作为主键。

ReadView:读视图，通过读视图实现版本信息比对，然后实现MVCC多版本并发控制。读视图的四大变量：

m_ids:当前活跃的事务的集合

min_trx_id:当前活跃的最小事务ID

max_trx_id:预分配事务ID，当前活跃的最大事务ID+1

creator_trx_id:创建这个ReadView的事务ID

通过和trx对比，trx就是DB_TRX_ID,和每一个undolog的记录进行对比。

undolog版本链，每个记录在提交后都会保留其undolog日志，undolog日志可以像链表一样串联起来，将这一条链叫做undolog版本链。

首先通过当前行数据中的隐藏字段DB_ROLL_PTR找到undo log版本链的第一个位置，进行顺序查询，找到相应的结果。这个过程中需要将每条记录的DB_TRX_ID(trx)进行对比，若 trx < min_trx_id或者trx == creator_trx_id或者 trx位于min_trx_id和max_trx_id之间但是并没有在m_ids中，则可以读取，若trx > max_trx_id，则没办法读取。按照这个规则进行遍历读取。

![1737113498998](C:\Users\17898\Documents\WeChat Files\wxid_ilsb8mab1nud22\FileStorage\Temp\1737113498998.png)

对于RC隔离级别，每次读都会产生一个新的ReadView。

对于RR隔离级别，只会在第一次读的时候产生一个新的ReadView。

**如果要实现当前读，需要加锁，加行排他锁。**

MVCC不能解决幻读问题，如果要解决幻读问题，可以加一个排他锁（临键锁），select ..... for update 锁一个范围。