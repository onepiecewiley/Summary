# **JUC总结**



### **什么是线程，什么是进程，什么是协程，什么是管程？**

程序是静态的，而进程就是运行的程序，它是系统资源分配的单位。

一个进程内部可以有多个线程，线程是操作系统调度的最小单位，所有的线程共享同一个进程的资源。线程的存在能够提高系统资源的利用和吞吐量，增加系统的并发性能。

并发：多条指令在一段时间内间隔执行。

并行：多条指令在同一时刻同时执行。



同步：需要等待结果返回后才能继续运行。

异步：不需要等待结果返回就可以继续运行。



线程和进程的关系：进程拥有资源，线程不拥有资源和进程独立，它存在于进程之中。

进程通信的方式有：共享存储，管道通信，消息队列。

共享存储：多个进程可以访问同一块内存区域，使用信号量来进行同步避免竞争。

管道通信：只支持半双工通信，链接一个读进程和一个写进程，管道就是一个pipe文件，一个时间内只允许一个进程访问。匿名管道：用于父子进程或兄弟进程的通信。通常位于内存中，不持久，只有通信的进程可以访问。   命名管道：以磁盘文件方式存在，任意两个进程的通信都可以。

消息队列：内核中存储消息的链表，能在不同进程之间提供全双工通信。

不同计算机的进程通信要依靠套接字进行网络传输，遵循HTTP协议。

由于线程共享进程的内存，所以通信比较简单，多个线程可以访问同一个共享变量。



**协程**是**一种轻量级的并发执行单元**，它允许在单个线程内**执行多个任务**，并且可以在执行过程中**暂停和恢复**，由程序自行控制切换。

协程是**可以挂起和恢复的函数**，通过它可以在一个线程内执行多个任务，且**任务切换是由程序控制的**，而非操作系统自动调度。（说白了是一个可以暂停的函数）

java本身不支持协程。



管程：管程就是**一个管理共享数据访问的机制**，它封装了数据和操作这些数据的代码，保证了线程在访问这些数据时是互斥的、同步的，避免了并发中的数据冲突问题。

管程就是保证多个线程安全访问共享资源的工具，它控制线程访问的顺序，避免出现冲突。准确来说它是一种同步机制。





### **创建进程的方法：**

1.继承Thread类，重写run方法

2.实现Runnable接口，重写run方法

3.实现Callable接口，冲洗call方法，然后创建一个这个类的实例对象，并且将它包装成一个FutureTask对象，将这个包装后对象再包装成线程对象，调用start()方法启动即可。（FutureTask支持获取返回结果，所以如果要利用一个线程的返回结果可以采用这个方法动态获取）

（FutureTask实现Runnable接口和Future接口，既可以用于在新线程中执行任务，又可以用来获取任务执行的结果。）其get()方法是一个同步方法，获取线程执行的结果，会阻塞当前线程。



### **start()方法和run()方法的区别**

如果调用一个线程的run()方法相当于函数调用，并不会开启一个新的线程，而是由主线程调用这个方法。

如果调用的start()方法,在其底层实际上执行的是start0()方法，这个方法是一个本地方法，会创建一个新的线程，由java虚拟机调用新线程，执行 `run()` 方法。

run() 方法中的异常不能抛出，只能 try/catch，异常不能跨线程传播回 main() 中**，因此必须在本地进行处理



### **线程的状态**

分为New,Runnable(就绪态和运行态）,Blocked,Wating,Timed Waiting,Terminated

![1735817192335](C:\Users\17898\Documents\WeChat Files\wxid_ilsb8mab1nud22\FileStorage\Temp\1735817192335.png)



API

sleep() : 从Running - - > Timed Waiting,但是不会释放对象锁，其他的线程可以使用interrupt方法打断正在睡眠的线程，这个时候会抛出InterruptedException，终止sleep()方法

yield:主动让出CPU的使用权，放弃CPU资源但没有放弃锁资源。

`join()` 是 `Thread` 类的方法，它用于确保当前线程等待调用 `join()` 方法的线程执行完毕后再继续执行。换句话说，当一个线程调用另一个线程的 `join()` 方法时，当前线程将会暂停执行，直到被调用的线程完成执行后，当前线程才会继续执行。



interrupt：打断线程，interrupted()判断线程是否被打断，打断返回true，并且清除打断标记

isInterrupted():判断当前线程是否被打断，不清除打断标记

打断一个线程 这个线程的中断标志会被设置为true  当这个线程执行sleep,wait的时候 这个标志会被重置为false





### **守护线程**

服务于用户线程，只要非守护线程运行结束，即使守护线程代码还没执行完毕，也会强制结束，JVM是守护线程。

常见守护线程：垃圾回收线程。



### **线程运行原理**

线程切换的时机：时间片到了，垃圾回收，更高优先级的线程来了，执行了wait,sleep等方法。

上下文切换的时候，需要操作系统保存当前线程的状态，恢复另外一个线程的状态，包括程序计数器，局部变量表等。

JVM的线程模型没有限定，以HotSpot为例，一个java线程对应一个内核线程。

线程调度是在内核态进行的，代码运行是在用户态进行的，因此线程的切换会导致用户态和内核态的转换，很消耗性能。

线程的状态信息保存在 **内核空间**。线程切换时，状态信息直接恢复到 **CPU 寄存器** 中，**不需要复制回用户空间**，只需要恢复执行所需的用户态上下文（如栈指针和程序计数器）。



### 线程同步

临界资源：一次仅允许一个进程使用的资源成为临界资源

临界区：访问临界资源的代码块

线程同步：指在多线程环境下，通过控制线程的执行顺序或访问共享资源，避免数据不一致或冲突，从而确保程序的正确性。

如何完成线程同步？使用锁机制，CAS

synchronized是java中用于实现同步机制的关键字。它的底层是一个可重入，不公平的重量级锁

在实例方法中被synchronized修饰的方法，锁对象是实例对象。

在静态方法中被synchronized修饰的方法，锁对象是类的Class对象。

synchronized修饰的方法不具备继承性。意味着子类对象的方法是一个普通方法，如果也被synchronized修饰则是同步方法。



### synchronized锁原理

对象是由对象头，实例数据和对齐填充组成的。

对象头由Mark Word和类型指针等组成。

实例数据存储对象的实例变量。

对齐填充是为了满足对齐要求填充的数据。



对象头Mark Word：包括了对象的哈希码，锁信息，GC状态等。

类型指针：指向对象所属类的指针，帮助JVM知道该对象属于哪个类。

Monitor是监视器，每个java对象都可以关联一个Monitor对象，这个Monitor是由操作系统提供的（并非显示地存在），存在堆里面。当使用地是重量级锁的时候，Mark Word会设置成指向Monitor对象地指针。

Monitor地组成包括WaitSet,EntryList（双向链表）,Owner;

Owner存储的是线程的id，表明当前是哪个线程拥有重量级锁，对象原有的MarkWord会存入栈帧里面的锁记录中，现在MarkWord指向Monitor(monitorenter字节码中这一行干的就是这个事情）。如果发生竞争，线程会被放入EntryList，等到锁释放后，Owner将被置为null，唤醒EntryList的第一个线程，此时如果由其他线程来竞争锁是有可能抢到锁的，因此synchronized并不公平。

调用 `obj.wait()` 后，当前线程会被加入到 `obj` 所关联的 Monitor 的 **waitSet** 中。当调用notify之后，会随机唤醒一个waitSet中的线程，调用notifyAll会唤醒所有waitSet中线程。`wait set` 中存储的是 **等待该对象的锁的线程**，而具体来说，是 **线程对象** 的引用，而不是线程的 ID。



### 锁升级流程

![image-20250102222743516](C:\Users\17898\AppData\Roaming\Typora\typora-user-images\image-20250102222743516.png)

首先明确为什么要有锁升级的概念？synchronized实现锁的原理是基于Monitor对象，但是不同的线程在进行重量级锁切换的时候，会涉及内核态和用户态的切换，导致大量的开销。具体在：

当加锁和解锁时：

1. **加锁**：如果线程竞争到一个重量级锁，操作系统会阻塞当前线程，进入 **内核态**。线程会被挂起，直到锁释放。
2. **解锁**：释放锁时，操作系统需要唤醒一个等待的线程。这个唤醒过程也涉及从 **内核态** 切换到 **用户态**，因为线程需要被调度来继续执行。
3. 每次线程阻塞和唤醒时，操作系统会将线程从用户空间转移到内核空间（或反之），这需要保存和恢复线程的状态，导致 **上下文切换**，这是非常消耗性能的。

因此我们可以通过锁升级，逐步提高锁的等级，减少不必要的内核态和用户态的切换，从而减少系统开销。

锁升级流程：

![img](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png)

**偏向锁**：当一个线程去获取锁的时候，如果发现没有其他线程与之竞争，则将其线程ID用CAS操作写入锁对象的Mark Word，锁状态标记为101，下一次获取锁的时候，直接通过查看锁对象Mark Word存储的标记，如果与线程ID一致，则直接获取锁。否则这个时候进行锁升级，将偏向锁升级成轻量级锁。**不会涉及用户态和内核态的切换**，因为它是 **轻量级的锁**，主要通过 **CAS 操作**（原子操作）来实现锁的获取。

偏向锁默认是延迟的，不会立刻生效，为了避免延迟，可以添加 `-XX:BiasedLockingStartupDelay=0`参数来禁止延迟。延迟的原因也是因为如果多个线程来抢锁，会频繁执行上述CAS写入比较操作，降低效率。添加 VM 参数 `-XX:-UseBiasedLocking` 禁用偏向锁。

当调用hashcode()后，JVM 可能会计算并缓存哈希值，这个过程会改变对象的 **内存结构**，比如 **对象头** 的一些字段（Mark Word变回去了）。因为偏向锁需要保留线程信息在对象头里，而 `hashCode()` 计算可能会干扰这个过程，所以对象计算过 `hashCode()` 后，无法进入偏向锁状态。

什么情况下偏向锁状态会被撤销？

1.锁对象调用hashcode()方法。

2.其他线程使用偏向锁对象，偏向锁会升级成轻量级锁。

3.调用wait/notify,这个时候会把线程加入WaitSet,此时锁对象的Mark Word存储的是指向Monitor的引用，而不是某个线程的ID。

**批量重偏向**：当撤销偏向锁阈值超过 20 次后（这里撤销的不是同一个偏向锁），JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程。

**批量撤销**：当偏向锁被频繁撤销（超过一定次数默认40次，这里撤销的不是同一个偏向锁，搞了半天想了半天才反应过了.....），JVM 会认为偏向锁选择错误，最终将整个类的所有对象都变为不可偏向锁，甚至新创建的对象也不再使用偏向锁。



**轻量级锁：**多个线程加锁，但是加锁时间错开，即没有竞争，用轻量级锁来优化，轻量级锁对用户不可见。

轻量级锁是可重入锁。

使用轻量级锁的时候，线程会在线程的栈帧创建一个锁记录结构，存储了对象的Mark Word。

![image-20250102222522010](C:\Users\17898\AppData\Roaming\Typora\typora-user-images\image-20250102222522010.png)

锁记录中第一项记录了锁记录的地址和锁状态00，Object Reference存储锁对象的引用。每次加锁尝试CAS将锁对象的Mark Word存入锁记录。CAS成功后，对象头存储的是锁记录地址和状态，表示由该线程给对象加锁。

![image-20250102223523049](C:\Users\17898\AppData\Roaming\Typora\typora-user-images\image-20250102223523049.png)

当使用轻量级锁的时候，会通过CAS将锁对象的Mark Word存入锁记录，如果成功，说明没有竞争。

如果失败，说明：有竞争，开始锁膨胀，将轻量级锁升级成重量级锁。

锁重入：如果发现Mark Word里面存储的锁记录指针指向的是当前线程的锁记录，则说明在执行锁冲入，则添加一条锁记录作为重入的计数。此时的锁记录指针位置为null。

![image-20250102224056519](C:\Users\17898\AppData\Roaming\Typora\typora-user-images\image-20250102224056519.png)

进行解锁的时候，如果遇到锁记录的第一个位置即锁记录指针的位置为null，则表示有重入直接删去这个锁记录。

如果不存在锁重入，则通过CAS操作将Mark Word恢复给锁对象，成功则解锁。失败则说明轻量级锁已经升级成重量级锁，则进入重量级锁解锁流程。



**重量级锁**：

当出现多个线程竞争锁的使用时，轻量级锁会升级成为重量级锁。

这个时候当线程进行加锁的时候，如果CAS失败，说明有其他线程在使用锁（轻量级锁）。此时，会通过当前锁对象存储的锁记录地址找到当前拥有锁的线程，将其线程ID存储到该锁对象关联的Monitor的Owner中，同时，将锁对象中目前该线程的锁记录引用修改为Monitor的引用。同时将当前线程加入到EntryList中，BLOCKED。

![image-20250103115928242](C:\Users\17898\AppData\Roaming\Typora\typora-user-images\image-20250103115928242.png)

当拥有锁的线程释放锁的时候，通过锁对象的Mark Word找到Monitor，然后将Owner设置为null,唤醒EntryList中的线程，然后重新竞争锁。

![image-20250103115933594](C:\Users\17898\AppData\Roaming\Typora\typora-user-images\image-20250103115933594.png)





### **锁优化**

重量级锁竞争会导致上下文切换，增大系统开销，可以通过自旋的方式，让没有竞争到锁的线程先自旋并不立即阻塞。

注意：自旋会消耗CPU时间，单核自旋会浪费时间。多核自旋才会有优势，自旋失败后才进入阻塞状态。自旋锁是JVM控制开启关闭的。



### **锁消除**

对于不可能出现竞争的共享数据的锁进行消除，由JIT来做。既然不存在竞争加锁也就没了意义，反而会带来额外系统开销，所以直接不加了。



### **锁粗化**

虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。锁粗化的目的是为了减少 **加锁解锁** 的次数，从而避免由于锁的频繁操作带来的性能损耗。



### **死锁**

多个线程同时被阻塞，互相等待对方的某个资源被释放，造成的无限期阻塞。

**产生的四个条件**

1.互斥条件

2.不可剥夺条件

3.请求和保持条件

4.循环等待条件

**定位死锁的方法：**

* **使用 jps 定位进程 id，再用 `jstack id` 定位死锁，找到死锁的线程去查看源码，解决优化**



### 活锁

线程没有被阻塞，但是频繁更改对方的终止条件，导致两个线程都没有办法执行结束，一直尝试失败尝试失败的过程。



### 饥饿

优先级太低，始终得不到CPU的调度，也无法结束



### wait-notify

这是Object的方法。sleep()方法属于Thread类，可用在任意位置。wait方法用于线程间通信。用在同步代码块或同步方法中。

底层原理：

* Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态
* BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片
* BLOCKED 线程会在 Owner 线程释放锁时唤醒
* WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒

**虚假唤醒**：notify随即唤醒，不一定环形的是目标线程。notifyAll唤醒所有线程。



### **LockSupport**

LockSupport.partk():暂停当前线程，挂起

LockSupport.unpark():恢复线程运行

LockSupport 出现就是为了增强 wait & notify 的功能：

* wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要
* park & unpark **以线程为单位**来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程
* park & unpark 可以先 unpark，而 wait & notify 不能先 notify。类比生产消费，先消费发现有产品就消费，没有就等待；先生产就直接产生商品，然后线程直接消费
* wait 会释放锁资源进入等待队列，**park 不会释放锁资源**，只负责阻塞当前线程，会释放 CPU





不可变类线程安全，无状态类线程安全。





### JMM内存模型

**JMM（Java Memory Model）** 是 **Java 内存模型**，它定义了 Java 程序中 **不同线程之间** 如何 **共享和同步数据** 的规则。

根据 JMM 的设计，系统存在一个主内存（Main Memory），Java 中所有变量都存储在主存中，对于所有线程都是共享的；每条线程都有自己的工作内存（Working Memory），工作内存中保存的是主存中某些**变量的拷贝**，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成

![image-20250103131500553](C:\Users\17898\AppData\Roaming\Typora\typora-user-images\image-20250103131500553.png)



### 线程安全要满足的三大特性

原子性：确保线程执行某些操作时，不会被其他线程中断，操作要么完全执行，要么完全不执行。

有序性：本线程内的所有操作都是有序的。防止JIT优化导致的指令重排从而威胁线程安全。

​	处理器在进行重排序时，必须要考虑**指令之间的数据依赖性**

* 单线程环境也存在指令重排，由于存在依赖性，最终执行结果和代码顺序的结果一致
* 多线程环境中线程交替执行，由于编译器优化重排，会获取其他线程处在不同阶段的指令同时执行

可见性：确保一个线程对共享资源的修改，能够及时反映到其他线程。volatile保证。

volatile能保证可见性和有序性（禁止指令重排），但不能保证原子性。

通过插入内存屏障来保证指令不发生乱序排序，开销比锁小很多。

经过jclasslib反汇编之后可以看到，volatile修饰的共享变量在写指令之后会加写屏障，在读指令只前会加读屏障。

写屏障之后的操作都不会被重排序到写屏障之前。

读屏障之前的操作都不会被重排序到读屏障之后。



synchronized为什么能保证有序性，可见性？

有序性：加了锁相当于单线程执行，数据依赖性存在，单线程的指令重排并不影响。

可见性：线程加锁前会把工作内存中共享变量的值全部清除，然后从主内存读取最新的值，当线程释放锁时会把共享变量写回主内存。



### Happens-before原则

**Happens-before原则**是**Java内存模型**中用来确保**操作间可见性和有序性**的规则，它规定了一个操作的结果对另一个操作可见，且保证前一个操作发生在后一个操作之前。

1. 程序次序规则 (Program Order Rule)：一个线程内，逻辑上书写在前面的操作先行发生于书写在后面的操作 ，因为多个操作之间有先后依赖关系，则不允许对这些操作进行重排序

2. 锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面（时间的先后）对同一个锁的 lock 操作，所以线程解锁 m 之前对变量的写（解锁前会刷新到主内存中），对于接下来对 m 加锁的其它线程对该变量的读可见

3. **volatile 变量规则**  (Volatile Variable Rule)：对 volatile 变量的写操作先行发生于后面对这个变量的读

4. 传递规则 (Transitivity)：具有传递性，如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C

5. 线程启动规则 (Thread Start Rule)：Thread 对象的 start()方 法先行发生于此线程中的每一个操作

6. 线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生

7. 线程终止规则 (Thread Termination Rule)：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行

8. 对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始



### CAS

无锁机制。Compare-And-Swap 

一种CPU并发原语。完全依赖硬件实现原子操作，操作系统范畴，原语必须是连续的不允许中断所以CAS是一条CPU原子指令。

作用：比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存的值一致为止

CAS借助volatile来实现可见性，保证每次读到的值都是最新值

CAS 特点：

* CAS 体现的是**无锁并发、无阻塞并发**，**线程不会陷入阻塞，线程不需要频繁切换状态（上下文切换，系统调用）**
* **CAS 是基于乐观锁的思想**

CAS 缺点：

- 执行的是循环操作，**如果比较不成功一直在循环，最差的情况某个线程一直取到的值和预期值都不一样，就会无限循环导致饥饿**，**使用 CAS 线程数不要超过 CPU 的核心数**，采用分段 CAS 和自动迁移机制
- 只能保证一个共享变量的原子操作
  - 对于一个共享变量执行操作时，可以通过循环 CAS 的方式来保证原子操作
  - 对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候**只能用锁来保证原子性**
- 引出来 ABA 问题



CAS 与 synchronized 总结：

* synchronized 是从悲观的角度出发：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程），因此 synchronized 也称之为悲观锁，ReentrantLock 也是一种悲观锁，性能较差
* CAS 是从乐观的角度出发：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。**如果别人修改过，则获取现在最新的值，如果别人没修改过，直接修改共享数据的值**，CAS 这种机制也称之为乐观锁



### Atomic

#### 常用API

常见原子类：AtomicInteger、AtomicBoolean、AtomicLong



#### 原子引用

如果这个对象包含多个字段或变量，那么你可以通过 **原子更新整个对象引用** 来间接地保证多个字段的原子性更新。

原子引用：对 Object 进行原子操作，提供一种读和写都是原子性的对象引用变量

原子引用类：AtomicReference、AtomicStampedReference、AtomicMarkableReference





### ABA问题

ABA 问题：当进行获取主内存值时，该内存值在写入主内存时已经被修改了 N 次，但是最终又改成原来的值

其他线程先把 A 改成 B 又改回 A，主线程**仅能判断出共享变量的值与最初值 A 是否相同**，不能感知到这种从 A 改为 B 又 改回 A 的情况，这时 CAS 虽然成功，但是过程存在问题

解决方法：版本号，在CAS的时候还要比较对应的版本号，版本号与预期一致才能修改。使用 **版本号** 或 **时间戳** 来跟踪对象的变化。

或者使用 **`AtomicStampedReference`**（带版本号的原子引用）来避免 ABA 问题。



### ThreadLocal原理

ThreadLocal 类用来提供线程内部的局部变量，这种变量在多线程环境下访问（通过 get 和 set 方法访问）时能保证各个线程的变量相对独立于其他线程内的变量

ThreadLocal 作用：

* 线程并发：应用在多线程并发的场景下

* 传递数据：通过 ThreadLocal 实现在同一线程不同函数或组件中传递公共变量，减少传递复杂度

* 线程隔离：每个线程的变量都是独立的，不会互相影响

##### 应用场景

ThreadLocal 适用于下面两种场景：

- 每个线程需要有自己单独的实例
- 实例需要在多个方法中共享，但不希望被多线程共享

ThreadLocal 方案有两个突出的优势： 

1. 传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，避免参数直接传递带来的代码耦合问题
2. 线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失



**原理**

JDK8之后，每个 Thread 维护一个 ThreadLocalMap，这个 Map 的 key 是 ThreadLocal 实例本身，value 是真正要存储的值

![image-20250103151525059](C:\Users\17898\AppData\Roaming\Typora\typora-user-images\image-20250103151525059.png)

* 每个 Thread 线程内部都有一个 Map (ThreadLocalMap)
* Map 里面存储 ThreadLocal 对象（key）和线程的私有变量（value）
* Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值
* 对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成副本的隔离，互不干扰

**内存泄漏**是指程序不再使用的内存未被及时释放，导致系统可用内存逐渐减少。

**这块内容极其复杂，现场推理吧，key也分强弱引用，内存泄露的场景均不同**

​	如果ThreadMap中的key是强引用，即使ThreadLocal本身的引用被回收了，ThreadLocal内存也无法释放，因为有强引用key指向它。

​	如果ThreadMap中的key是弱引用，那ThreadLocal本身的引用被回收了，ThreadLocal内存可以释放，但是!!!,value是没办法释放的，value如果是强引用。且value将永远不会被回收，也不会被访问。

**内存泄漏** 场景（**小林Coding这块讲的有点问题 不清不楚**）：

1. **该线程未结束**，但 `ThreadLocal` 中的对象已经不再被使用，且对象仍然保持在 `ThreadLocalMap` 中，没有被清理，导致无法回收。
2. 另外，如果 **线程结束后**，`ThreadLocal` 的值还没有被移除，线程池中的线程复用时，可能会继续持有之前线程的数据，造成不必要的内存占用。这种场景下ThreadMap中的数据无法删除不说，ThreadLocal的内存也无法释放因为有引用指向它。

最常见的泄漏场景是 **线程复用且未调用 `remove()`**，导致线程池中的线程持有不再需要的 `ThreadLocal` 数据。记住要使用remove()。

![img](https://cdn.xiaolincoding.com//picgo/1719982991053-c983c4b8-7c5f-4e2d-a90d-5b42ebd533d5.png)

![05833382-3387-45f7-b141-95dc4990dc89](C:\Users\17898\AppData\Local\Temp\05833382-3387-45f7-b141-95dc4990dc89.png)



### **AQS**

抽象同步队列器。是很多同步类实现所依赖的的对象。

核心思想：

当被请求的资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态。

如果请求的共享资源被占用，则将其放入阻塞队列里面，等待被唤醒。

AQS是公平锁和非公平锁的积累。包含一个volatile int state,ExclusiveOwnerThread,head,tail。

AQS 通过维护一个 **FIFO 队列** 和 **一个共享状态**（通常是一个整数）来控制线程之间的访问权限。

是一个抽象类。

AQS 用状态属性来表示资源的状态（分**独占模式和共享模式**），子类需要定义如何维护这个状态，控制如何获取锁和释放锁

* 独占模式是只有一个线程能够访问资源，如 ReentrantLock
* 共享模式允许多个线程访问资源，如 Semaphore

`state` 是一个 **整型值**（`int` 类型），用于表示 **同步器的当前状态**。它的作用是帮助管理和控制线程的访问权限，比如是否允许获取锁，锁的状态是否已释放，或者是共享资源的剩余数量等。

head指向阻塞队列的头部，阻塞队列是一个双向链表的形式，tail指向尾部，ExclusiveOwnerThread是当前持有锁的线程。



### ReentrantLock

ReentrantLock 相对于 synchronized 具备如下特点：

1. 锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的
2. 性能：新版本 Java 对 synchronized 进行了很多优化，synchronized 与 ReentrantLock 大致相同
3. 使用：ReentrantLock 需要手动解锁，synchronized 执行完代码块自动解锁
4. **可中断**：ReentrantLock 可中断，而 synchronized 不行。用lockInterruptibly()函数，可以被其他线程用interrupt打断。
5. **公平锁**：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁
   * **ReentrantLock 可以设置公平锁，synchronized 中的锁是非公平的**
   * 不公平锁的含义是阻塞队列内公平，队列外非公平
6. 锁超时：尝试获取锁，超时获取不到直接放弃，不进入阻塞队列。使用tryLock()函数尝试获取直到获取否则一直尝试，tryLock(long timeout, TimeUnit unit)，带限定时间的尝试。
   * ReentrantLock 可以设置超时时间，synchronized 会在阻塞队列中一直等待
7. 锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象，更细粒度的唤醒线程。**`synchronized`** 只能绑定一个条件，通过一个对象的锁实现。
8. 两者都是可重入锁



### 公平锁和非公平锁

非公平锁NoFairSync继承自AQS，主要原理是：

加锁：当没有竞争的时候，会直接把ExclusiveOwnerThread设置为当前线程，state设置为1,此时如果竞争出现，竞争的线程会通过CAS操作尝试将state从0改成1，如果失败进入acquire逻辑。调用tryAcquire函数即尝试获取锁（第二次尝试获取），当尝试获取的时候如果失败，则会带哦用addWaiter逻辑将当前线程封装成node入队，阻塞当前线程。（只有当锁本身空闲或者进入锁重入的时候才有可能加锁成功，否则必然失败）。加入队列后，由于队列第一个节点是哑节点，如果该线程的节点位于哑节点之后，会再次尝试去获取锁，如果成功了则成功拿到锁，从阻塞队列中删除，否则则进入是否被阻塞的逻辑，这个时候如果前驱节点的waitStatus不是-1,会把前驱节点的waitStatus改成-1，返回false;waitStatus等于-1的节点用来唤醒下一个节点。此时，再次去尝试获取一次锁，如果还是获取失败，则这次进入是否阻塞的逻辑会返回true，直接被阻塞(park)。如果本身前驱节点的waitStatus就是-1，则直接返回true就被阻塞。

如果不是位于哑节点之后，则只会重试三次。而不是四次，少了一次。

![image-20250103220432596](C:\Users\17898\AppData\Roaming\Typora\typora-user-images\image-20250103220432596.png)





解锁，当持有锁的线程释放锁，进入release流程，将exclusiveOwnerThread设置为null,state = 0。当队列不空，并且head的waitStatus为-1时，则从后往前唤醒队列中的节点（插入的时候采用的尾插法，首先赋值的是尾节点的前驱节点，此时前驱节点的 next 并没有指向尾节点，从前遍历会丢失尾节点），恢复它的运行(unpark)。

唤醒的线程会开始竞争锁，此时如果有其他线程来竞争，可能就和他抢占锁，因此这是不公平的。



公平锁：

与非公平锁主要区别在于 tryAcquire 方法：先检查 AQS 队列中是否有前驱节点，没有才去 CAS 竞争。否则加入阻塞队列。



条件变量：

ReentrantLock 的条件变量比 synchronized 强大之处在于支持多个条件变量。通过newCondition()方法可以获取Condition对象。

Condition 类 API：

* `void await()`：当前线程从运行状态进入等待状态，释放锁
* `void signal()`：唤醒一个等待在 Condition 上的线程，但是必须获得与该 Condition 相关的锁

使用流程：

* **await / signal 前需要获得锁**
* await 执行后，会释放锁进入 ConditionObject 等待（总体流程是将 await 线程包装成 node 节点放入 ConditionObject 的条件队列，如果被唤醒就将 node 转移到 AQS 的执行阻塞队列，等待获取锁，**每个 Condition 对象都包含一个等待队列**）
* await 的线程被唤醒去重新竞争 lock 锁（假设 Thread-1 要来唤醒 Thread-0，进入 ConditionObject 的 doSignal 流程，**取得等待队列中第一个 Node**，即 Thread-0 所在 Node，必须持有锁才能唤醒, 因此 doSignal 内线程安全）

* **线程在条件队列被打断会抛出中断异常**

* 竞争 lock 锁成功后，从 await 后继续执行

![image-20250103222826380](C:\Users\17898\AppData\Roaming\Typora\typora-user-images\image-20250103222826380.png)



### 线程池

概念：一个池子，里面有很多创建好的线程，供你用，可以回收，省去了创建和销毁对象的操作。

线程池的核心思想：**线程复用**，同一个线程可以被重复使用，来处理多个任务

池化技术 (Pool) ：一种编程技巧，核心思想是资源复用，在请求量大时能优化应用性能，降低系统频繁建连的资源开销



#### 阻塞队列

和普通队列最大的不同就是添加和删除是阻塞添加和阻塞删除，保证线程安全，

* 阻塞添加 put()：当阻塞队列元素已满时，添加队列元素的线程会被阻塞，直到队列元素不满时才重新唤醒线程执行
* 阻塞删除 take()：在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作（一般会返回被删除的元素）

有界队列：有固定大小

无界队列：没有固定大小

常用有界队列：ArrayBlockQueue

常用无界队列：LinkedBlockingQueue，PriorityBlockQueue（带优先级），LinkedBlockingDeque（双向）



#### 线程池

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-线程池工作原理.png)

构造方法：

public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)

参数:

1.核心线程数，可以最小可以同时运行的线程数

2.最大线程数，存放任务数量达到阻塞队列容量上限的时候，可以同时运行的线程数量变为这个，其是由核心线程和救急线程组成的。

3.救急线程销毁的时间，超过这个时间就被销毁

4.时间单位

5.阻塞队列，存放提交但未被执行的任务

6.线程工厂，用于创建新线程。它定义了线程创建的逻辑，比如设置线程的名称、优先级、是否为守护线程等。

7.拒绝策略：线程到达最大线程数仍有新任务时会执行拒绝策略，包括

* AbortPolicy：让调用者抛出 RejectedExecutionException 异常，**默认策略**
* CallerRunsPolicy：让调用者运行的调节机制，将某些任务回退到调用者，从而降低新任务的流量
* DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常
* DiscardOldestPolicy：放弃队列中最早的任务，把当前任务加入队列中尝试再次提交当前任务
